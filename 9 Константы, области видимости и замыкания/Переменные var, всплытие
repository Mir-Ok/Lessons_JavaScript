var имеют важное отличие от let - они вспылывают в начало функции, внутри которой они объявляются,
то есть к ней можно обратится до объявления.
Но всплывает только объявление, не значение, поэтому если вызвать до объявления и после, 
мы получим сначчала underfined, а потом значение

function doSmth() {
  cobsole.log(x);  // нет ошибки, но underfined
  var x = 123;    
  cobsole.log(x);  // 123
}

по сути это равнозначно:

function doSmth() {
  var x; 
  cobsole.log(x);  // нет ошибки, но underfined
  x = 123;    
  cobsole.log(x);  // 123
}

Причем всплытие происходит даже из вложенных блоков, в отличии от let 
Даже если это условный блок и он никогда не выполнится

function doSmth() {
  cobsole.log(x);  // нет ошибки, но underfined
  if (false) {
    var x = 123; 
  }     
  cobsole.log(x);  // нет ошибки, но underfined присваивание не выполнилось
}

По сути то же самое, что

function doSmth() {
  var x; 
  cobsole.log(x);  // нет ошибки, но underfined
  if (false) {
    x = 123;  
  }
  cobsole.log(x);  // нет ошибки, но underfined присваивание не выполнилось
}

С этими переменными работать опасно, предпочитаем ему let, const
Это легаси код

--------------------------------
Всплывать может и функция, она доступна ниже и выше по коду относительно объявления
Доступно для именованных функций
Потому что если неименованную функцию поместить в let переменную, она будет работать по тем же
правилам, что и let, и до объявления не вызывается, не всплывает

Именованные функции (Function Declaration) - function name() {}
Вызывать ее можно как в самом блоке, так и после него. Но лучше не делать этого внутри блоков,
не декларировать, только запутаетесь сами. Объявляем функцию в скрипте

Анонимные функции (опущено название) - function () {}

Присвоение функции в переменную или константу (Function Expression)
let/const/var name = function () {}
