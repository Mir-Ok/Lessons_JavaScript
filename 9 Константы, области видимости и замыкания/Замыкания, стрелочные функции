Все именованные сущности имеют свои области видимости, блок и функция создают свои блоки.
Все переменные доступны в текущей или родительской области видимости.

Замыкание (closure) - функция, которая имеет доступ к именам из родительской области видимости.
В JS это по умолчанию, но в PHP для этого надо явно указывать, что из глобалки можно брать
конкретной функции, через use? замыкание создаются явно

Как это выглядит в JS

let name = 'Ivan';

function closureGreet() {
console.log(name);
}

closureGreet(); // Ivan

Если изменим значение, то внутри функции тоже изменится

-------------------------------------------------------

Стрелочные функции

До этого мы объявляли при помощи ключевого слова function или через помещение в переменную.
Есть еще один способ =>, но свойства несколько отличаются. Нет именования, нет пространства this (берет
переменные из глобальной области видимости).
Классическая функция оперирует своими внутренними переменными через this/ 
И только если внутренних нет, то будет обращаться к глобальной ОВ

// Синтаксис (аргументы) => {тело функции}

const arrowFn = (name, surname) => {
console.log(name + ' ' + surname);
}
arrowFn('Иван','Иванов')  // Иван Иванов

// если аргумент один, скобки можно опустить

const arrowFn = name => {
console.log(name);
}
arrowFn('Иван')  // Иван 

// если аргументов вообще нет, то ()
const arrowFn = () => {
console.log('Иван');
}
arrowFn()  // Иван 

--------------------
Если опустить фигурные скобки, то функция вернет результат, словно это return

const arrowFn = (name, surname) => `Привет, ${name} ${surname}`;
arrowFn('Иван','Иванов')  // 'Привет, Иван Иванов'

Это равнозначно записи ниже

const arrowFn = (name, surname) => {
  return `Привет, ${name} ${surname}`;
};
arrowFn('Иван','Иванов')

---------------------

Стрелочная функция может иметь одну инструкцию и мы хотим, чтобы она вернула объект

const arrowFn = (name, surname) => { name, surname };

Чтобы показать, что это не тело функции, а объект, добавим ()

const arrowFn = (name, surname) => ({ name, surname });
arrowFn('Иван','Иванов')  // {name: 'Иван', surname: 'Иванов'}

------------------------------------------------------------------
Обработка событий стрелочными функциями

const me = {
  name: 'Oksa',
  surname: 'Mir',
  // Функция-метод объекта, имеет fhis
  getFullName() {
      return `${this.name} ${this.surname}`;
  },
  // Аналогичная функция, но стрелочная
  getFullNameArr: () => `${this.name} ${this.surname}`,
};

console.log(me.getFullName());  // Oksa Mir
// console.log(me.getFullNameArr());  // undefined

Чтобы заработало, нужно в глобальной ОВ создать переменные и убрать this 

const me = {
  name: 'Oksa',
  surname: 'Mir',
  // Функция-метод объекта, имеет fhis
  getFullName() {
      return `${this.name} ${this.surname}`;
  },
  // Аналогичная функция, но стрелочная
  getFullNameArr: () => `${name} ${surname}`,
};

console.log(me.getFullName());  // Oksa Mir

let name = 'Oksa';
let surname = 'Mir';
console.log(me.getFullNameArr());  // Oksa Mir
